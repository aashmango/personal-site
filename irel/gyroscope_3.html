<html>
<head>
	<title>Gyroscope Pers.</title>
	<style>
	body { margin: 0; 
		background-color: #1f8b70;}
		canvas { width: 100%; height: 100% }

			#poo {
			position: absolute;
			color: white;
			background-color: none;
			width: 200px;
			height: 50px;
			text-align: left;
			font-family: arial;
			margin-left: 20px;
			margin-top: 20px;
		}
		</style>
	</head>

	<body>
		<div id = "poo"> Best viewed on mobile or devices with device orientation feedback </div>

		<script src="js/three.min.js"></script>

		<script src="js/controls/OrbitControls.js"></script>

		<script src="js/controls/DeviceOrientationControls.js"></script>





		<script>

		var camera, controls, scene, renderer;
		

		init();
		animate();
		

		function init() {



			scene = new THREE.Scene();


			camera = new THREE.OrthographicCamera( window.innerWidth/-2, window.innerWidth/2, window.innerHeight/-2,window.innerHeight/2 );

			// camera = new THREE.PerspectiveCamera( 85, window.innerWidth / window.innerHeight, 1, 8000 );

			camera.position.x = 0;
			camera.position.y = 0;
			camera.position.z = 0;
			// camera.lookAt( scene.position );


			// controls = new THREE.OrbitControls( camera, renderer.domElement );
			// 	//controls.addEventListener( 'change', render ); // add this only if there is no animation loop (requestAnimationFrame)
			// 	// controls.enableDamping = true;
			// 	// controls.dampingFactor = 1;
			// 	// controls.enableZoom = true;

			controls = new THREE.DeviceOrientationControls( camera );

			renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			
			renderer.setClearColor( 0x1f8b70 );


			for ( var i = 0; i < 10; i ++ ) {

				for ( var u = 0; u < 10; u ++ ) {

					for ( var d = 0; d < 10; d ++ ) {


					fixed = 20;
				

					var geometry = new THREE.BoxGeometry( fixed, fixed, fixed);

					for ( var b = 0; b < geometry.faces.length; b ++ ) {
						if (b % 3 == 0) {
							geometry.faces[ b ].color.setHex( 0xfb3c7f );
						} 
						else {
							geometry.faces[ b ].color.setHex( 0xfff000 );

						}

						// geometry.faces[ b ].color.setHex( Math.random() * 0xffffff );
					}

					var material = new THREE.MeshBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

					
					
					

					var mesh = new THREE.Mesh( geometry, material );

				

					mesh.position.x = (u * 60) - 220 ;

					


					mesh.position.y = (i * 60) - 220 ;

					
					mesh.position.z = (d * 60) - 220 ;
					


					var pos_a = mesh.position.x;
					var pos_b = mesh.position.y; 
					var pos_c = mesh.position.z;

					console.log(pos_a + "," + pos_b + "," + pos_c);





					mesh.rotation.x = u/15 * Math.PI;
					mesh.rotation.y = i/15 * Math.PI;
					mesh.rotation.z = d/15 * Math.PI;
					//mesh.rotation.y = Math.random() * 2 * Math.PI;

					mesh.updateMatrix();
					mesh.matrixAutoUpdate = true;
					scene.add( mesh );

				}
			  }
			}
		}

		console.log(scene.children.length);

			function animate() {
				requestAnimationFrame( animate );
				controls.update(); 

				render();
			}


			function render() {

			var timer = Date.now() * 0.001;

			//console.log(timer);

			for ( var k = 0, m = scene.children.length; k < m; k ++ ) {

					var object = scene.children[ k ];

					// console.log(k + " and " + m)

					object.rotation.x += 0.05;
					// object.rotation.y = timer * 25;

				}




			renderer.render( scene, camera );
			}



			</script>
		</body>
		</html>