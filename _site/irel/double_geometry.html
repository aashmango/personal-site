<!DOCTYPE html>
<html lang="en">
<head>
	<title>MONKEY</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<style>
	body {
		color: #000;
		font-family:Monospace;
		font-size:13px;
		text-align:center;
		font-weight: bold;
		background-color: #fff;
		margin: 0px;
		overflow: hidden;
	}

	#info {
		color:#000;
		position: absolute;
		top: 0px; width: 100%;
		padding: 5px;
	}

	a {
		color: red;
	}
	</style>
</head>

<body>
<div id="container"></div>
<div id="info">
	orbit controls example
</div>

<script src="js/three.min.js"></script>

<script src="js/controls/OrbitControls.js"></script>

<script src="js/Detector.js"></script>

<script>

if ( ! Detector.webgl ) Detector.addGetWebGLMessage();


var camera, controls, scene, renderer;

var planegeometry, material, mesh;

var baseplane;

var clock = new THREE.Clock();

var main_group = new THREE.Object3D();

var main_group2 = new THREE.Object3D();

var xpos, ypos;

var width = window.innerWidth
var height = window.innerHeight

init();
animate();

function init() {

scene = new THREE.Scene();
scene.fog = new THREE.FogExp2( "#000000", 0.001 );

renderer = new THREE.WebGLRenderer();
renderer.setClearColor( scene.fog.color );
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setSize( window.innerWidth, window.innerHeight );

var container = document.getElementById('container');
container.appendChild( renderer.domElement );



camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 1500 );
camera.position.x = 800;
camera.position.y = 300;
camera.position.z = 800;
// camera.up = new THREE.Vector3(0,0,1);


controls = new THREE.OrbitControls( camera, renderer.domElement );
controls.enableDamping = true;
controls.dampingFactor = 0.25;
controls.enableZoom = true;

// MATERIALS
// material_2 =  new THREE.MeshPhongMaterial( { color:0xffffff, shading: THREE.FlatShading } );
material2 = new THREE.MeshBasicMaterial({color:0xe2e2e2, wireframe: true, fog: true, wireframeLinewidth: 0.1,transparent: true, opacity: 0.3});

material = new THREE.MeshLambertMaterial({color:0xe2e2e2, wireframe: false, fog: true,transparent: true, opacity: 0.3, wireframeLinewidth: 1});

basematerial = new THREE.MeshBasicMaterial({color:0x2d2d2d, wireframe: true, fog: true,transparent: false, wireframeLinewidth: 0.05, opacity: 1});


baseplane = new THREE.PlaneGeometry( 1500, 1500, 100, 100);

basemesh = new THREE.Mesh( baseplane, basematerial );
// console.log(basemesh)

basemesh.rotation.z = Math.PI * 0.5;
basemesh.rotation.x = Math.PI * 0.5;
basemesh.rotation.y = 0;
basemesh.position.z = 200;
basemesh.position.x = 200;
basemesh.position.y = 0;

scene.add(basemesh);

// LIGHTS

// light = new THREE.DirectionalLight( 0xffffff, 1 );
// light.position.set( 1, 10, 1 );
// scene.add( light );

// light = new THREE.DirectionalLight( 0xffffff, 1 );
// light.position.set( -1, -1, -1 );
// scene.add( light );

var pointLight = new THREE.PointLight( 0xe6c700, 5, 500 );
pointLight.position.set( 50, 140, 50 );
scene.add( pointLight );

var pointLight2 = new THREE.PointLight( 0xa63e14, 10, 500 );
pointLight2.position.set( 650, 100, 450 );
scene.add( pointLight2 );

var pointLight3 = new THREE.PointLight( 0x558a86, 5, 500 );
pointLight3.position.set( 300, 40, 750 );
scene.add( pointLight3 );

// var sphereSize = 1;
// var pointLightHelper = new THREE.PointLightHelper( pointLight, sphereSize );
// scene.add( pointLightHelper );

// var pointLightHelper2 = new THREE.PointLightHelper( pointLight2, sphereSize );
// scene.add( pointLightHelper2 );

// RESIZE

window.addEventListener( 'resize', onWindowResize, false );

}

function onWindowResize() {

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );

}

function animate() {

	requestAnimationFrame( animate );

controls.update(); // required if controls.enableDamping = true, or if controls.autoRotate = true

render();

}

function render() {
	var delta = clock.getDelta(),
	time = clock.getElapsedTime() * 10;

	undulate(time)
	undulate2(time)

	renderer.render( scene, camera );
	// camera.position.x += (Math.log(time))/50;
	// camera.position.z += (Math.log(time))/50;
	// camera.position.y -= (Math.log(time))/50;

	camera.position.x += (Math.sin(time/100) * 100) / 40;
	camera.position.z += (Math.cos(time/100) * 100) / 40;
	camera.position.y -= time/800;

	// console.log(Math.log(time));

	// if (camera.position.y < 350) {
	// 	camera.position.y -= 0.1;
	// 	camera.position.z += 0.2;
	// 	camera.position.x += 0.2;

	// };

	// for ( var q = 0, l = basemesh.geometry.vertices.length; q < l; q ++ ) {
			
	// 		basemesh.geometry.vertices[ q ].y += Math.sin(q) * time;
	// 		basemesh.updateMatrix();
	// 		basemesh.matrixAutoUpdate = false;

	// 		scene.add( basemesh );
	// 	}

}

for ( var boo = 0; boo < 20; boo ++ ) {
	for ( var poo = 0; poo < 20; poo ++ ) {
		var rand_height = Math.floor((Math.random() * 13) + 3);
		var rand_width = Math.floor((Math.random() * 25) + 5);
		var rand_breadth = Math.floor((Math.random() * 25) + 5);

		// xpos = Math.floor((Math.random() * 45) + 8);
		// ypos = Math.floor((Math.random() * 45) + 8

		xpos = Math.floor((Math.random() * 850) + 0);
		ypos = Math.floor((Math.random() * 850) + 0);

		module((xpos + boo),(ypos + poo),rand_width,rand_breadth,rand_height)
		module_wireframe((xpos + boo),(ypos + poo),rand_width,rand_breadth,rand_height)

		// xpos = 40;
		// ypos = 40;

		// module((xpos * boo),(ypos * poo),rand_width,rand_breadth,rand_height)
		// module_wireframe((xpos * boo),(ypos * poo),rand_width,rand_breadth,rand_height)

	}
}

function module (x, y, x_size, y_size, height) {
	var group = new THREE.Group();

	for ( var i = 0; i < height; i ++ ) {

		planegeometry = new THREE.BoxGeometry( x_size, 15, y_size);

		// mesh = THREE.SceneUtils.createMultiMaterialObject( planegeometry, materials );

		mesh = new THREE.Mesh( planegeometry, material );

		mesh.position.x = x - 50;
		mesh.position.y = 0;
		mesh.position.z = y - 50;

		// mesh.rotation.y = (Math.random()/2)*Math.PI*2;

		for ( var q = 0, l = mesh.geometry.vertices.length; q < l; q ++ ) {
			
			mesh.geometry.vertices[ q ].y += i * 14 - 100;
			mesh.updateMatrix();
			mesh.matrixAutoUpdate = false;

			group.add( mesh );
		}

}
// console.log(group)
main_group.add(group)
}

scene.add(main_group)

function module_wireframe (x, y, x_size, y_size, height) {
	var group2 = new THREE.Group();

	for ( var i = 0; i < height; i ++ ) {

		planegeometry2 = new THREE.BoxGeometry( x_size, 15, y_size);

		// mesh = THREE.SceneUtils.createMultiMaterialObject( planegeometry, materials );

		mesh2 = new THREE.Mesh( planegeometry2, material2 );

		mesh2.position.x = x - 50;
		mesh2.position.y = 0;
		mesh2.position.z = y - 50;

		// mesh.rotation.y = (Math.random()/2)*Math.PI*2;

		for ( var q = 0, l = mesh2.geometry.vertices.length; q < l; q ++ ) {
			
			mesh2.geometry.vertices[ q ].y += i * 14 - 100;
			mesh2.updateMatrix();
			mesh2.matrixAutoUpdate = false;

			group2.add( mesh2 );
		}

}
// console.log(group)
main_group2.add(group2)
}

scene.add(main_group2)


function undulate (time) {

for ( var q = 0, e = main_group.children.length; q < e; q ++ ) {

	if (q % 2 == 0) {

	var each_column = main_group.children[q]

	for ( var c = 0, j = each_column.children.length; c < j; c ++ ) {
		each_mesh = each_column.children[c].geometry.vertices

		for ( var i = 0, l = each_mesh.length; i < l; i ++ ) {

			// initial_y = (c) * Math.sin( i / 5 + 1 / 10 ) + (c*5);

			initial_y = (c) * Math.sin( i / 5 + ( time + i ) / 10 ) + (c*5);
			// initial_y = (c^2) * Math.sin( i / 5 + ( time + i ) / 10 ) + (c^2);

			// if (toss < 0.5) {
			// each_mesh[ i ].y = each_mesh[ i ].y 
			// }

		// 	if (basic = true) {
		// 		each_mesh[ i ].y = each_mesh[ i ].y 
		// 	}
		// 	else {
			each_mesh[ i ].y = initial_y
		// }
		// 	// }

		}

		each_column.children[c].geometry.verticesNeedUpdate = true;
		each_column.children[c].geometry.dynamic = true;
	}
	}

	
}
}

function undulate2 (time) {

for ( var q = 0, e = main_group2.children.length; q < e; q ++ ) {

	

	if (q % 2 == 0) {

	var each_column = main_group2.children[q]

	for ( var c = 0, j = each_column.children.length; c < j; c ++ ) {
		each_mesh = each_column.children[c].geometry.vertices

		for ( var i = 0, l = each_mesh.length; i < l; i ++ ) {

			initial_y = (c) * Math.sin( i / 5 + ( time + i ) / 10 ) + (c*5);
			// initial_y = (c^2) * Math.sin( i / 5 + ( time + i ) / 10 ) + (c^2);

			// 	if (toss < 0.5) {
			// each_mesh[ i ].y = each_mesh[ i ].y 
			// }

			// else {
			// 	each_mesh[ i ].y = initial_y
			// }

		// 	if (basic = true) {
		// 		each_mesh[ i ].y = each_mesh[ i ].y 
		// 	}
		// 	else {
			each_mesh[ i ].y = initial_y
		// }
			


			// each_mesh[ i ].y = initial_y

		}

		each_column.children[c].geometry.verticesNeedUpdate = true;
		each_column.children[c].geometry.dynamic = true;
	}

}

}
}




</script>

</body>
</html>
